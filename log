#!/bin/bash
#########################################################################
#
#   Copyright 2009 David Liang
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#   Revisions:
#   2009-07-23  File created
#   2009-08-20  Rewrite with improved functionality
#   2009-09-28  Updated to conform to entries.pl
#
#########################################################################

PROG=$(basename "$0")
VERSION="0.8"

# default tabstop
TS=4

# character for negated patterns on the command line
NOT=':'

# comment indicator
COMMENT='#'

# header line must be a comment
HEADER="$COMMENT"'!log'

# text processing script
GET=entries.pl
SEP=':'

# default options for script
opts=(-c "$COMMENT")

# default printing options
popts=(--preserve)

[ ! "$COLUMNS" ] && COLUMNS=80

printUsage() {
local SPCS=$(printf '%*s' ${#PROG} '')
cat << -EOF-
Usage: $PROG  [FILE]  ...
Operation:    $SPCS                           Parameters:
       $SPCS  m | p[fl] | o[fl] | t | e[fl]   [RANGE]...  [[$NOT]PATTERN]...
       $SPCS  d                               [RANGE: [+-]N | N- | N-M ]...
       $SPCS  x | i                       [N] [LINE|-]
       $SPCS  a | s                           [LINE|-]
       $SPCS  n[DELIM]  FILE                  [LINE|-]
       $SPCS  c | r | h
-EOF-
[ "$1" = "h" ] && echo "
Options: [--help] [-wnc] [-i] [-a] [-f] [-e] [-q]"
}

helpText() {
printf "%s" "$PROG $VERSION

Command-line interface for displaying and managing text logs.

$(printUsage)

A FILE may be specified immediately after \"$PROG\" or after the \
operational keyword. If not present, it defaults to \"$PROG\". FILE is a \
text file in \$LOG_DIR (${LOG_DIR:-not set}) or a path to a text file, the \
first line of which should conform to this format:

  $HEADER [MODELINE] [template:N] [DEFAULT] [DELIM]

DELIM is a non-alphanumeric sequence used to delineate the file's entries. \
If it's not present, each non-blank line counts as an entry. Comments, \
which begin with '$COMMENT' and continue to the end of the line, are \
ignored. If DELIM is not specified, comments and blank lines are \
associated with the previous non-blank line.

DEFAULT specifies a default operation for the file; it may be any of the \
operations listed below except [dncr]. Additionally, it may be \"i-\", \
\"a-\", or \"s-\" for adding an entry using input from stdin. The default \
operation in the absence of DEFAULT is \"p\".

If \"template\" is specified, the Nth entry will be used as a template for \
new entries. MODELINE is currently supported for Vim modelines of the form \
\"vim:set {options}:\".

\$EDITOR should be set to launch your preferred text editor. The command \
must run in the foreground.

Operations:

Where allowed, each RANGE selects one or more entries as follows (N, M ≥ 0):

  N           Nth entry
  +N  -N      first/last N entries
  N-          Nth entry onwards
  N-M         entries N to M (inclusive)

For certain operations, PATTERN limits entries to those whose first lines \
contain the Perl regular expression PATTERN. If PATTERN is preceded by \
'$NOT', select entries that do NOT match the pattern.

For the operations [poe], the letters \"f\" and \"l\" may be appended to \
specify only the first or last matching entry, respectively.

The possible operations are:

  m           print a random entry
  p[fl]       print all selected entries
  o[fl]       print a one-line summary for each entry
  t           count the total number of selected entries
  e[fl]       edit selected entries or (without parameters) the entire file

For \"e\", if more than one matching entry is found, you will be prompted \
to select from a menu. A line will be read in the form of

  [ N | N- | -N | N-M ]...

where you can numerically select one or more entries for editing. A return \
on an empty line will select all displayed entries, and $(stty -a | \
awk -v RS=';' '$1=="eof" {print $3}') will cancel selection. To \
automatically edit the first or last matching entry, use \"ef\" or \"el\" \
instead of \"e\".

  d           delete entries in range
  x [N]       extend entry N ≥ 0 (the last entry by default)
  i [N]       insert an entry before entry N ≥ 1 (1 by default)
  a           append an entry
  s           insert an entry in sorted order
              i.e. before the first entry that sorts lexicographically after
  n[DELIM]    create a new FILE in \$LOG_DIR, with optional DELIM
  c   r       clear/remove FILE
  h           print the usage string

For the operations [iasxn], the rest of the command line, if present, will \
be used as input for the entry. Alternatively, \"-\" specifies that input \
should be read from stdin. If neither is present, the default action for \
the operations [ias] is to launch \$EDITOR (${EDITOR:-not set}); for \
\"x\", to read input from stdin; and for \"n\", to exit after file creation.

Options:
  -h, --help  print this help message and exit
  -w          do not wrap entries at $COLUMNS
  -n          do not number entries
  -c          canonically number entries
  -i          ignore case when matching PATTERN's
  -a          all:
              use entire entries, including comments, for searching/sorting
              the alternative is to use only the first non-blank line
  -f          edit entries with context:
              edit FILE itself when adding or editing a single entry
              open FILE concurrently if editing multiple entries
  -e          use alternate editor \$LOG_EDITOR (${LOG_EDITOR:-not set})
  -q          quiet (suppress informative messages)

" | fold -sw $COLUMNS
}

errorUsage() {
    printUsage >&2
    [ $# -gt 0 ] && echo >&2 $'\n'"$PROG: $@"
    exit 2
}

cleanUp() {
    rm -rf "$TEMPFILE" "$TEMPDIR"
}

errorExit() {
    local -i code=$?
    if [[ "$1" =~ ^[0-9]+$ ]]; then
        code=$1 && shift
    elif [ $code -eq 0 ]; then
        code=3
    fi
    [ $# -gt 0 ] && echo >&2 "$PROG: $@"
    cleanUp
    exit $code
}
trap "errorExit aborted" 2 3
trap "errorExit terminated" 1 15

testExit() {
    if [ "$1" -ne 0 ]; then
        errorExit "$@"
    fi
}

if ! type "$GET" &>/dev/null; then
    errorExit 127 "$GET: command not found"
elif [ ! -d "$LOG_DIR" ]; then
    if [ ! "$LOG_DIR" ]; then
        errorExit 1 "Please setup and export \$LOG_DIR"
    else
        errorExit "$LOG_DIR: No such directory"
    fi
fi

# options
argv=()

_no_wrap=
_no_numb=
_canonical=
_all=
_file=
_quiet=

_vim=
_edit_all=

EXTERN="$EDITOR"
_EXTERN="EDITOR"

while [ $# -gt 0 ]; do
    case "$1" in
    -w)         _no_wrap=1 && shift
                ;;
    -w*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _no_wrap=1
                ;;
    -n)         _no_numb=1 && shift
                ;;
    -n*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _no_numb=1
                ;;
    -c)         _canonical=1 && shift
                ;;
    -c*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _canonical=1
                ;;
    -i)         popts+=(-i) && shift
                ;;
    -i*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                popts+=(-i)
                ;;
    -a)         _all=1 && shift
                ;;
    -a*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _all=1
                ;;
    -f)         _file=1 && shift
                ;;
    -f*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _file=1
                ;;
    -e)         shift
                EXTERN="$LOG_EDITOR"
                _EXTERN="LOG_EDITOR"
                ;;
    -e*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                EXTERN="$LOG_EDITOR"
                _EXTERN="LOG_EDITOR"
                ;;
    -q)         _quiet=1 && shift
                ;;
    -q*)        rest="-${1:2}" && shift
                set -- "$rest" "$@"
                _quiet=1
                ;;
    -h*|--help) helpText
                exit 0
                ;;
    -\?)        printUsage h
                exit 0
                ;;
    --)         shift && break
                ;;
    -[^0-9]*)   errorUsage "Unknown option: ${1:0:2}"
                ;;
    *)          argv+=("$1") && shift
                ;;
    esac
done

set -- "${argv[@]}" "$@"

[ ! "$_all" ] && opts+=(--one-line)

[[ "$EXTERN" == *vim* ]] && _vim=1

# operation and file
OP=
LOG=
DELIM=
LNUM=

getOp() {
    if [ "$1" = "h" ]; then
        printUsage h
        exit 0
    elif [[ "$1" == [mpotedxiasncr] ]]; then
        OP="$1"
        _edit_all=1
    elif [[ "$1" =~ ^([poe])([fl])$ ]]; then
        OP="${BASH_REMATCH[1]}"
        case "${BASH_REMATCH[2]}" in
        f)  popts+=(--first)
            ;;
        l)  popts+=(--last)
            ;;
        esac
    elif [[ "$1" =~ ^n[^[:alnum:]]+$ ]]; then
        OP="n"
        DELIM="${1#n}"
    elif [[ "$1" == [a-z] ]]; then
        errorUsage "Unrecognized operation: $1"
    fi
    return $(( 1 - ${#OP} ))
}

if getOp "$2"; then
    [ ! "$1" ] && errorUsage
    LOG="$1" && shift 2
    _LOG="${LOG/#$HOME/~}"
elif getOp "$1"; then
    shift
fi

getFile() {
    if [[ "$LOG" =~ ^(/|\.\.?/) ]]; then
        FILE="$LOG"
        LOG_DIR="$PWD"
    else
        FILE="$LOG_DIR/$LOG"
    fi
}

if [ "$OP" = "n" ]; then
    if [ ! "$LOG" ]; then
        [ ! "$1" ] && errorUsage
        LOG="$1" && shift
        _LOG="${LOG/#$HOME/~}"
    fi
    getFile
    [ -e "$FILE" ] && errorExit "$_LOG: File or directory exists"
    if [ "$DELIM" ]; then
        if [ "$_vim" ]; then
            [[ "$DELIM" == *:* ]] && errorExit 1 "DELIM contains ':'"
            HEAD="vim:set fdm=marker fmr=$DELIM,$DELIM: $DELIM"1
        else
            HEAD="$DELIM"
        fi
        HEAD="$HEADER $HEAD"
    else
        HEAD="$HEADER"
    fi
    DIR=$(dirname -- "$FILE")
    if [ ! -d "$DIR" ]; then
        mkdir -p "$DIR" || errorExit "$DIR: Could not create directory"
    fi
    echo "$HEAD" >"$FILE" || errorExit "$_LOG: Could not create file"
    [ $# -eq 0 ] && exit
    OP="a"
else
    if [ ! "$LOG" ]; then
        if [[ "$1" == */*               ||
              -f "$LOG_DIR/$1"          ||
              -f "$1"                   ||
              $# -gt 0 && "$OP" == [cr] ]]

        then LOG="$1" && shift
        else LOG="$PROG"
        fi
        _LOG="${LOG/#$HOME/~}"
    fi
    getFile
    if [ ! -f "$FILE" ]; then
        if [ -f "$LOG" ]; then
            FILE="$LOG"
            LOG_DIR="$PWD"
        else
            errorExit "$_LOG: No such file"
        fi
    fi
fi

BASE=$(basename -- "$LOG")
opts+=("$FILE")

# header line
read HEAD <"$FILE"
if [ $? -ne 0 ]; then
    if [ ! -s "$FILE" ]
    then errorExit "$_LOG: File empty"
    else errorExit "$_LOG: Permission denied"
    fi
elif [ "${HEAD:0:${#HEADER}}" != "$HEADER" ]; then
    errorExit 1 "$_LOG: Unrecognized file format"
fi

SPECS="${HEAD:${#HEADER}}"
if [ ! "$OP" ]; then
    if [[ "$SPECS" =~ \ ([mtxh]|[poe][fl]?|[ias]-?)( |$) ]]; then
        case "${BASH_REMATCH[1]}" in
        ?-) getOp "${BASH_REMATCH[1]:0:1}"
            [ $# -eq 0 ] && set -- -
            ;;
        *)  getOp "${BASH_REMATCH[1]}"
            ;;
        esac
    else
        OP="p"
    fi
fi

DELIM="${SPECS##* }"
if [[ "$DELIM" =~ ^[^[:alnum:]]+1?$ ]]; then
    _DELIM=$(echo "$DELIM" | perl -ne 'chomp; print quotemeta')
    opts+=(-d "$_DELIM")
    TYPE=entry
else
    DELIM=
    TYPE=line
fi

# functions
echoc() {
    local argv=() c
    while [[ "$1" == -* ]]; do
        argv+=("$1") && shift
    done
    [ $# -eq 0 ] && echo "${argv[@]}" && return
    case "$1" in
        r|red)      c=31 ;;
        g|green)    c=32 ;;
        y|yellow)   c=33 ;;
        b|blue)     c=34 ;;
        p|purple)   c=35 ;;
        c|cyan)     c=36 ;;
        *)          c=$1 ;;
    esac
    shift
    [[ ! "$c" =~ ^[0-9]+$ ]] && return 1
    echo -en "\e[$c;1m"
    echo "${argv[@]}" "$@"
    echo -en "\e[0m"
}
makeTemp() {
    local tempdir type
    if [ -d "$HOME/tmp" ]
    then tempdir="$HOME/tmp"
    else tempdir=/tmp
    fi
    if [ "$1" = TEMPFILE ]; then
        type=file
        TEMPFILE=$(mktemp -q -p "$tempdir" "$BASE.$TYPE${2:+.}$2.XXX")
    else
        type=directory
        TEMPDIR=$(mktemp -dq -p "$tempdir" "$PROG.$$.XXX")
    fi
    if [ $? -ne 0 ]; then
        errorExit "Could not create temp $type"
    fi
}
TEMPFILE= TEMPDIR=
newTemp() {
    eval "$1=\$(mktemp -q -p \"$TEMPDIR\" \"$BASE.$TYPE${2:+.}$2.XXX\")"
    if [ $? -ne 0 ]; then
        errorExit "Could not create temp file"
    fi
}
parseRanges() {
    popts+=($(
    for arg in "${@:2}"; do
        echo "$arg"
    done | awk -v OPT="$1" -v SEP="$SEP" '
    function valid(num) {
        if (num != "0" && num ~ /^0/)
            return 0;
        else
            return 1;
    } BEGIN { count = 0 } {
        if ($0 ~ /^[+-]?[0-9]+$/) {
            first = substr($0, 1, 1);
            rest  = substr($0, 2);
            if (first == "+") {
                if (! valid(rest)) exit;
                arg = SEP rest;
            } else if (first == "-") {
                if (rest == 0 || ! valid(rest)) exit;
                arg = $0 SEP;
            } else {
                if (! valid($0)) exit;
                arg = $0;
            }
            print OPT, arg;
        } else if ($0 ~ /^[0-9]+-[0-9]*$/) {
            split($0, a, "-");
            if (! valid(a[1]) || ! valid(a[2])) exit;
            if (a[2] != "") {
                if (a[1] >= a[2]) exit;
                print OPT, a[1] SEP a[2];
            } else
                print OPT, a[1] SEP;
        } else
            exit;
        count += 1;
    } END { exit count }' ))
}
parsePatterns() {
    local arg pattern
    for arg in "$@"; do
        if [[ "$arg" == $NOT* ]]
        then popts+=(-G "${arg#$NOT}")
        else popts+=(-g "$arg")
        fi
    done
}
checkWritable() {
    if [ ! -w "$FILE" ]; then
        errorExit "$_LOG: Permission denied"
    fi
}
checkEditor() {
    if [ ! "$EXTERN" ]; then
        errorExit 1 "Please setup and export \$$_EXTERN"
    fi
}
appendDelim() {
    if [ "$DELIM" ]; then
        local same_line
        if [[ "$DELIM" == *1 ]]; then
            same_line=-n && DELIM+=' '
        elif [[ "$input" == "$DELIM"* ]]; then
            same_line=-n
        fi
        echo $same_line "$DELIM" >>"$1" || errorExit
    fi
}
appendTemplate() {
    if [[ "$SPECS" =~ \ template:([0-9]+)( |$) ]]; then
        if [ "${BASH_REMATCH[1]}" -eq 0 ]; then
            appendDelim "$1"
            $GET -r -f0 "${opts[@]}" | tail -n +2 >>"$1" || errorExit
            testExit ${PIPESTATUS[0]}
        else
            $GET -r -f"${BASH_REMATCH[1]}" "${opts[@]}" >>"$1" || errorExit
        fi
    else
        appendDelim "$1"
    fi
}
parseModeline() {
    if [ "$MODELINE" ]; then
        return 0
    elif [[ "$_vim" && "$SPECS" =~ \ vim?:\ *(set? [^:]+): ]]; then
        MODELINE="${BASH_REMATCH[1]}"
        if [[ "$MODELINE" =~ \ (ts|tabstop)=([1-9][0-9]*)( |$) ]]; then
            TS="${BASH_REMATCH[2]}"
        fi
        return 0
    else
        return 1
    fi
}
edit() {
    local command=($EXTERN "$@")
    if [ "$1" != "$FILE" ]; then
        if [ "$_vim" ]; then
            parseModeline && command+=(-c "${MODELINE//\"/\\\"}")
            command+=(-f -c "silent! normal! zO")
        fi
        [ "$_file" ] && command+=("$FILE")
    else
        if [ "$LNUM" ]; then
            command+=(+"$LNUM")
            [ "$_vim" ] && command+=(-c "silent! normal! zO")
        else
            [ "$_vim" ] && command+=(-c "silent! %foldclose")
        fi
    fi
    (cd "$LOG_DIR" && "${command[@]}" 2>/dev/null)
    local code=$?
    if [ $code -eq 127 ]; then
        errorExit $code "$command: command not found"
    elif [ $code -ne 0 ]; then
        errorExit $code
    fi
}
getTargets() {
    if [[ "$1" != *$'\n'* ]]; then
        targets=($(echo "$1" | awk 'END {print $1}'))
        return
    fi
    echo >&2 -n "$1"$'\n'"$PS3" && read
    if [ $? -ne 0 ]; then
        echo
        targets=()
        return
    fi
    if [ ! "$REPLY" ]; then
        targets=($(echo "$1" | awk '{print $1}'))
    else
        targets=($(echo "$1"$'\n'"$REPLY" | awk '{
            if (i != "") {
                choices[i] = 0;
                max = i;
            }
            i = $1;
        } END {
            for (i = 1; i <= NF; ++i) {
                if ($i ~ /^[0-9]+$/) {
                    a[1] = a[2] = $i;
                } else if ($i ~ /^-[0-9]+$/) {
                    split($i, a, "-");
                    a[1] = 0;
                } else if ($i ~ /^[0-9]+-[0-9]*$/) {
                    split($i, a, "-");
                    if (a[2] == "")
                        a[2] = max;
                } else {
                    print $i;
                    exit 1;
                }
                for (j = a[1]; j <= a[2]; ++j) {
                    if (j in choices)
                        choices[j] = 1;
                }
            }
            for (i in choices) {
                if (choices[i])
                    print i;
            }
        }'))
        [ $? -ne 0 ] && errorExit 1 "Bad selection: ${targets[0]}"
    fi
}
getRanges() {
    ranges=($(echo "$@" | awk '{
        nxt = 0;
        for (i = 1; i <= NF; ++i) {
            if ($i == nxt+1)
                print nxt;
            else if ($i > nxt)
                print nxt "'$SEP'" $i-1;
            print "t" $i;
            nxt = $i + 1;
        }
    } END { print nxt "'$SEP'" }'))
}
getInput() {
    input=$(cat /dev/stdin)
    if [ $? -ne 0 -o -z "$input" ]; then
        errorExit 1
    fi
}
getIndex() {
    local sopts=("${opts[@]}") i count
    for i in "${!sopts[@]}"; do
        [ "${sopts[$i]}" = "$FILE" ] && unset sopts[$i] && break
    done
    while (( count == 0 )); do
        if (( ${count+1} )); then
            echo >&2 -n "no entry found: [d]iscard or [E]dit? " && read
            [ $? -ne 0 ] && echo && errorExit 1
            [[ "$REPLY" == d* ]] && errorExit 0
            edit "$1"
        fi
        count=$($GET --count "$1" "${sopts[@]}") || errorExit
    done
    N=$($GET --sort --list <($GET -r -f1 "$1" "${sopts[@]}")               \
                           <($GET -r -f"1$SEP" "${opts[@]}") "${sopts[@]}" \
        | awk '{
            count += 1;
            if ($1 == 1) {
                print count; exit;
            }
        }'
        testExit ${PIPESTATUS[0]})
    [ ! "$N" ] && errorExit
}

# main
if [[ "$OP" == [mp] ]]; then
    [ "$OP" = "p" ]   && popts+=(--blank-line)
    [ ! "$_no_wrap" ] && popts+=(--wrap=$COLUMNS)
fi
if [[ "$OP" == [mpo] ]]; then
    [ ! "$_no_numb" ] && popts+=(-n ' ')
    [ "$_canonical" ] && popts+=(--canonical)
fi
if [[ "$OP" == [mpoe] ]]; then
    parseModeline
    (( TS != 8 ))     && popts+=(--tabs=$TS)
fi
unset input

case "$OP" in

m|p|o|t)
    parseRanges -f "$@" || shift $?
    parsePatterns "$@"
    case "$OP" in
    m)  $GET "${opts[@]}" "${popts[@]}" -m
        ;;
    p)  $GET "${opts[@]}" "${popts[@]}"
        ;;
    o)  $GET "${opts[@]}" "${popts[@]}" --first-line | cut -c -$COLUMNS
        exit ${PIPESTATUS[0]}
        ;;
    t)  $GET "${opts[@]}" "${popts[@]}" --count
        ;;
    esac
    ;;

e)  checkEditor
    if [ $# -eq 0 -a "$_edit_all" ]; then
        edit "$FILE"
        exit
    fi
    parseRanges -f "$@" || shift $?
    parsePatterns "$@"
    list=$( $GET -n" " --first-line "${opts[@]}" "${popts[@]}" |
            cut -c -$COLUMNS; testExit ${PIPESTATUS[0]} )
    [ ! "$list" ] && errorExit 0
    getTargets "$list"
    if [ ${#targets[@]} -eq 0 ]; then
        exit
    elif [ "$_file" -a ${#targets[@]} -eq 1 ]; then
        LNUM=$(( $( $GET -r -a -e"${targets[0]}$SEP" "${opts[@]}" |
                    wc -l; testExit ${PIPESTATUS[0]} ) + 1 ))
        edit "$FILE"
        exit
    fi

    declare -a TEMP HASH
    makeTemp
    for N in "${targets[@]}"; do
        newTemp TEMP[$N] "$N"
        $GET -r -f"$N" "${opts[@]}" >"${TEMP[$N]}" || errorExit
        HASH[$N]=$(md5sum "${TEMP[$N]}" 2>/dev/null)
    done
    edit "${TEMP[@]}"
    for N in "${targets[@]}"; do
        if [ "${HASH[$N]}" -a \
             "${HASH[$N]}" = "$(md5sum "${TEMP[$N]}" 2>/dev/null)" ]; then
            unset TEMP[$N]
        fi
    done
    if [ ${#TEMP[@]} -gt 0 ]; then
        newTemp TEMPFILE
        getRanges "${!TEMP[@]}"
        for range in "${ranges[@]}"; do
            if [[ "$range" == t* ]]; then
                cat "${TEMP[${range#t}]}"       >>"$TEMPFILE" || errorExit
            else
                $GET -r -f"$range" "${opts[@]}" >>"$TEMPFILE" || errorExit
            fi
        done
        checkWritable
        cp "$TEMPFILE" "$FILE" || errorExit
    fi
    cleanUp
    ;;

d)  [ $# -eq 0 ] && exit
    popts=()
    parseRanges -e "$@" || shift $?
    [ $# -gt 0 ] && errorUsage "Invalid argument for $OP: $1"
    makeTemp TEMPFILE
    $GET -r -a "${opts[@]}" "${popts[@]}" >"$TEMPFILE" || errorExit
    checkWritable
    read <"$TEMPFILE"
    if [ "$REPLY" != "$HEAD" ]
    then echo "$HEAD" | cat - "$TEMPFILE" >"$FILE"
    else cp "$TEMPFILE" "$FILE"
    fi || errorExit
    cleanUp
    ;;

x)  if [[ $# -eq 0 || ! "$1" =~ ^[0-9]+$ ]]
    then N=
    else N="$1" && shift
    fi
    extendMsg() {
        local after
        [ "$TYPE" = "line" ] && after=' after'
        echoc blue "extend $_LOG${N:+$after $TYPE $N}:"
    }
    if [ $# -eq 0 -o $# -eq 1 -a "$1" = "-" ]; then
        set --
        [ ! "$_quiet" ] && extendMsg
        getInput
    else
        input="$@"
    fi
    checkWritable
    if [ ! "$N" ]; then
        printf "%s\n" "$input" >>"$FILE" || errorExit
    else
        makeTemp TEMPFILE
        $GET -r -a -e"$((N+1))$SEP" "${opts[@]}"  >"$TEMPFILE" || errorExit
        printf "%s\n" "$input" >>"$TEMPFILE"
        $GET -r    -e"$SEP$N"       "${opts[@]}" >>"$TEMPFILE" || errorExit
        cp "$TEMPFILE" "$FILE" || errorExit
        cleanUp
    fi
    if [ $# -gt 0 -a ! "$_quiet" ]; then
        extendMsg
        echo "$@"
    fi
    ;;

i|a|s)
    checkEditor
    if [ "$OP" = "i" ]; then
        if [[ $# -eq 0 || ! "$1" =~ ^[1-9][0-9]*$ ]]
        then N=1
        else N="$1" && shift
        fi
    fi
    if [ $# -eq 1 -a "$1" = "-" ]; then
        set --
        [ ! "$_quiet" ] && echoc blue "new $_LOG $TYPE:"
        getInput
    elif [ $# -gt 0 ]; then
        input="$@"
    elif [ "$_file" -a "$OP" != "s" ]; then
        checkWritable
        if [ "$OP" = "i" ]; then
            makeTemp TEMPFILE
            $GET -r -a -e"$N$SEP"    "${opts[@]}"  >"$TEMPFILE" || errorExit
            LNUM=$(( $(cat "$TEMPFILE" | wc -l) + 1 ))
            appendTemplate "$TEMPFILE"
            $GET -r -e"$SEP$((N-1))" "${opts[@]}" >>"$TEMPFILE" || errorExit
            cp "$TEMPFILE" "$FILE" || errorExit
            cleanUp
        else
            LNUM=$(( $(cat "$FILE" | wc -l) + 1 ))
            appendTemplate "$FILE"
        fi
        edit "$FILE"
        exit
    fi

    if [ "$OP" = "a" ]; then
        makeTemp TEMPFILE
    else
        makeTemp
        newTemp TEMPFILE "$N"
    fi
    if [ "${input+set}" ]; then
        appendDelim "$TEMPFILE"
        printf "%s\n" "$input" >>"$TEMPFILE"
    else
        appendTemplate "$TEMPFILE"
        edit "$TEMPFILE"
    fi
    if (( $(cat "$TEMPFILE" 2>/dev/null | wc -m) > ${#DELIM}+1 )); then
        [ "$OP" = "s" ] && getIndex "$TEMPFILE"
        checkWritable
        if [[ "$OP" == [is] ]]; then
            $GET -r -e"$SEP$((N-1))" "${opts[@]}" >>"$TEMPFILE" || errorExit
            newTemp NEWFILE
            $GET -r -a -e"$N$SEP" "${opts[@]}" >"$NEWFILE" || errorExit
            cp "$NEWFILE" "$FILE" || errorExit
        fi
        insertMsg() {
            if [ "$N" ]
            then echoc blue "insert $_LOG $TYPE $N$1"
            else echoc blue "append $TYPE to $_LOG$1"
            fi
        }
        cat "$TEMPFILE" >>"$FILE" || errorExit
        if [ ! "$_quiet" ]; then
            if [ $# -gt 0 ]; then
                insertMsg :
                echo "$@"
            elif [ -z "$input" ]; then
                insertMsg ...$'\n'ok
            fi
        fi
    fi
    cleanUp
    ;;

c)  [ $# -gt 0 ] && errorUsage
    echoc red -n "clear $_LOG? " && read
    if [[ "$REPLY" == [Yy]* ]]; then
        makeTemp TEMPFILE
        $GET -r -f0 "${opts[@]}" >"$TEMPFILE" || errorExit
        checkWritable
        cp "$TEMPFILE" "$FILE" || errorExit
        cleanUp
    else
        errorExit 1
    fi
    ;;

r)  [ $# -gt 0 ] && errorUsage
    echoc red -n "remove $_LOG? " && read
    [[ "$REPLY" == [Yy]* ]] && rm "$FILE"
    ;;

*)  errorExit "Fatal error: undefined operation"
    ;;

esac

# vim:set ts=4 sw=4 et:
